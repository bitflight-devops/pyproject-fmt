---
phase: 03-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .pre-commit-hooks.yaml
  - .pre-commit-config.yaml
  - tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "User can pip install pyproject-fmt and run pyproject_fmt as a CLI command"
    - "User can add pyproject-fmt to .pre-commit-config.yaml and it formats pyproject.toml on commit"
    - "The hook requires only one run -- formatting is idempotent (no oscillation)"
    - "taplo binary is found automatically in the pre-commit virtualenv"
  artifacts:
    - path: ".pre-commit-hooks.yaml"
      provides: "Pre-commit hook definition for pyproject-fmt"
      contains: "id: pyproject-fmt"
    - path: "tests/test_integration.py"
      provides: "Integration tests verifying pre-commit invocation pattern and idempotency"
      contains: "subprocess.run"
    - path: ".pre-commit-config.yaml"
      provides: "Self-hosted pyproject-fmt hook entry"
      contains: "id: pyproject-fmt"
  key_links:
    - from: ".pre-commit-hooks.yaml"
      to: "pyproject.toml [project.scripts]"
      via: "entry: pyproject_fmt matches console_scripts entry point"
      pattern: "entry: pyproject_fmt"
    - from: ".pre-commit-hooks.yaml"
      to: "pyproject.toml [project.dependencies]"
      via: "language: python triggers pip install of all declared dependencies including taplo"
      pattern: "language: python"
    - from: "tests/test_integration.py"
      to: "src/pyproject_fmt/cli.py"
      via: "subprocess invocation of pyproject_fmt entry point"
      pattern: "pyproject_fmt"
---

<objective>
Create the pre-commit hook definition, integration tests verifying pre-commit-compatible invocation, and self-host the hook in the project's own config.

Purpose: This is the final phase deliverable -- making pyproject-fmt usable as a pre-commit hook and verifying the end-to-end installation and invocation flow works correctly.

Output: `.pre-commit-hooks.yaml` at repo root, integration test file, updated `.pre-commit-config.yaml` with self-hosted hook.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-integration/03-RESEARCH.md
@.pre-commit-config.yaml
@pyproject.toml
@tests/test_pyproject_fmt.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pre-commit hook definition and self-host in project config</name>
  <files>.pre-commit-hooks.yaml, .pre-commit-config.yaml</files>
  <action>
Create `.pre-commit-hooks.yaml` at the repository root with the following exact content (pattern verified from tox-dev/pyproject-fmt and ruff-pre-commit in research):

```yaml
- id: pyproject-fmt
  name: pyproject-fmt
  description: Sort and format pyproject.toml files
  entry: pyproject_fmt
  language: python
  files: (^|/)pyproject\.toml$
  args: []
  require_serial: false
  minimum_pre_commit_version: "3.2.0"
```

Key details:
- `entry: pyproject_fmt` matches the `[project.scripts]` console entry point
- `language: python` ensures pre-commit creates a venv and installs all declared dependencies (including taplo binary via pip)
- `files: (^|/)pyproject\.toml$` matches pyproject.toml at root and in subdirectories -- do NOT use `types: [toml]` which would match all .toml files
- `require_serial: false` -- each file processed independently, taplo subprocess is stateless
- `minimum_pre_commit_version: "3.2.0"` -- reasonable floor supporting all features used
- Default entry has no `--check` flag -- formatters fix in-place by default; users add `args: [--check]` in their config for CI

Then update `.pre-commit-config.yaml` to add pyproject-fmt as a self-hosted hook. Add a new `repo: local` entry (separate from the existing ty hook block) with a hook that invokes `uv run pyproject_fmt`. Use `language: system` for the local hook since it runs from the development environment, not from a pre-commit-managed venv. Set `files: (^|/)pyproject\.toml$` and `pass_filenames: true`.

The local hook entry should look like:
```yaml
  # pyproject-fmt - self-hosted hook for dogfooding
  - repo: local
    hooks:
      - id: pyproject-fmt
        name: pyproject-fmt
        entry: uv run pyproject_fmt
        language: system
        files: (^|/)pyproject\.toml$
        pass_filenames: true
```

Place this AFTER the ruff hooks and BEFORE the ty hook block.
  </action>
  <verify>
1. `cat .pre-commit-hooks.yaml` shows correct YAML with all required fields
2. `python -c "import yaml; yaml.safe_load(open('.pre-commit-hooks.yaml'))"` parses without error (or use `check-yaml` equivalent)
3. `grep 'id: pyproject-fmt' .pre-commit-config.yaml` confirms self-hosted entry exists
4. The existing hooks in `.pre-commit-config.yaml` are preserved unchanged
  </verify>
  <done>
`.pre-commit-hooks.yaml` exists at repo root with correct hook definition. `.pre-commit-config.yaml` contains self-hosted pyproject-fmt hook entry alongside existing hooks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for pre-commit hook invocation pattern</name>
  <files>tests/test_integration.py</files>
  <action>
Create `tests/test_integration.py` with subprocess-based integration tests that verify pyproject-fmt works as pre-commit would invoke it. These tests use `subprocess.run` (not CliRunner) to test the actual installed entry point, which is how pre-commit invokes hooks.

Tests to implement:

1. **`test_entry_point_exists`** -- Verify `pyproject_fmt` is callable via `subprocess.run(["uv", "run", "pyproject_fmt", "--version"])`. This confirms the console_scripts entry point is properly installed.

2. **`test_precommit_fix_invocation`** -- Simulate pre-commit's fix-mode invocation:
   - Write an unformatted `pyproject.toml` to a temp file (e.g., `'[project]\nname="test"\n'`)
   - Run `subprocess.run(["uv", "run", "pyproject_fmt", str(toml_file)])` (pre-commit passes filenames as positional args)
   - Assert exit code 0
   - Assert file content changed (was reformatted)

3. **`test_precommit_idempotency`** -- The critical anti-oscillation test:
   - Format a file once (as in test 2)
   - Read the formatted content
   - Run `subprocess.run(["uv", "run", "pyproject_fmt", "--check", str(toml_file)])` on the already-formatted file
   - Assert exit code 0 (no changes needed -- proves one-pass convergence)

4. **`test_precommit_check_mode_detects_unformatted`** -- Verify check mode (CI pattern):
   - Write an unformatted `pyproject.toml` to temp file
   - Run with `["uv", "run", "pyproject_fmt", "--check", str(toml_file)]`
   - Assert exit code non-zero (changes needed)
   - Assert original file is unchanged (check mode is read-only)

5. **`test_multiple_files_invocation`** -- Verify multi-file invocation (monorepo pattern):
   - Create two temp `pyproject.toml` files with different unformatted content
   - Run `subprocess.run(["uv", "run", "pyproject_fmt", str(file1), str(file2)])` (pre-commit passes all matching files)
   - Assert exit code 0
   - Assert both files are reformatted

Use `tmp_path` pytest fixture for temp files. All subprocess calls should use `capture_output=True, text=True` for diagnostic output on failure. Use `timeout=30` on subprocess calls to prevent hanging. Import `subprocess` and `pathlib.Path`.

Run `uv run pytest tests/test_integration.py -v` to verify all tests pass.
  </action>
  <verify>
1. `uv run pytest tests/test_integration.py -v` -- all 5 tests pass
2. `uv run pytest tests/ -v` -- all existing tests still pass (no regressions)
3. `uv run ruff check tests/test_integration.py` -- no lint errors
  </verify>
  <done>
5 integration tests pass, covering: entry point existence, fix-mode invocation, idempotency (anti-oscillation), check-mode detection, and multi-file invocation. All existing tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. `.pre-commit-hooks.yaml` exists at repo root with `id: pyproject-fmt`, `language: python`, `files: (^|/)pyproject\.toml$`, `entry: pyproject_fmt`
2. `.pre-commit-config.yaml` contains self-hosted pyproject-fmt hook
3. All integration tests pass: `uv run pytest tests/test_integration.py -v`
4. Full test suite passes: `uv run pytest tests/ -v`
5. Entry point works: `uv run pyproject_fmt --version` returns version string
6. Lint passes: `uv run ruff check .`
</verification>

<success_criteria>
- `.pre-commit-hooks.yaml` defines a valid pre-commit hook that pre-commit can discover and execute
- Integration tests prove the CLI works when invoked the way pre-commit invokes hooks (subprocess with filenames as positional args)
- Idempotency is verified: formatting twice produces no diff (no oscillation in pre-commit)
- Self-hosted hook in `.pre-commit-config.yaml` dogfoods the tool on the project's own pyproject.toml
- All tests (existing + new) pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-integration/03-01-SUMMARY.md`
</output>
